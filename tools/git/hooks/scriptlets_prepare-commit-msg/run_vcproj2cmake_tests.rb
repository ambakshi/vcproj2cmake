#!/usr/bin/env ruby

def git_hook_get_repo_root()
  `git rev-parse --show-toplevel`.chomp
end

def git_hook_fail(msg)
  puts "#{$0}: #{msg}"
  exit 1
end

# For testing (to keep content repeatedly committable rather than committing it)
def git_hook_fail_pseudo()
  git_hook_fail("Pseudo failure, for testing")
end

def git_hook_ok(msg)
  puts "#{$0}: #{msg}"
  # NO exit here!
end

git_repo_root_dir = git_hook_get_repo_root()

tests_dir = "#{git_repo_root_dir}/tests/st"

converter_bin = "#{git_repo_root_dir}/scripts/vcproj2cmake_recursive.rb"

# Simply run vcproj2cmake_recursive.rb and let its exit code
# decide whether to fail the git hook.
# TODO: should probably create test scripts specific to (within) that area,
# which are then responsible for doing a clean reproducible test run each.

output = nil
test_failed_st_reason = nil

arr_ruby_bin_candidates = [ 'ruby1.8', 'ruby1.9.1', 'ruby' ]

arr_ruby_bin_ok = arr_ruby_bin_candidates.collect do |ruby_bin|
  output = `which #{ruby_bin} 2>/dev/null`
  next if not $?.success?
  output.split("\n")
end

#arr_ruby_bin = arr_ruby_bin_ok

# Optimization: it's ok to test a single ruby variant per each invocation only,
# since a version-dependent failure effect ought to be rather rare
# as opposed to generic failure of our commits under test.
arr_ruby_bin = []
if arr_ruby_bin_ok.length
  idx = rand(arr_ruby_bin_ok.length)
  arr_ruby_bin.push(arr_ruby_bin_ok[idx])
end

test_failed_st_reason = "converter script could not be executed (no Ruby?)"
Dir.chdir(tests_dir) do |path|
  arr_cmdline = [ 'RUBY_PLACEHOLDER', converter_bin, path, '2>&1' ]
  arr_ruby_bin.each do |ruby_bin|
    arr_cmdline[0] = ruby_bin
    output = `#{arr_cmdline.join(' ')}`

    if $?.success?
      test_failed_st_reason = nil
    else
      test_failed_st_reason = "converter script indicated failure (cmdline #{arr_cmdline.join(' ')}, exit code: #{$?.exitstatus}, output #{output})"
      break
    end
  end
end

if not test_failed_st_reason.nil?
  git_hook_fail(test_failed_st_reason)
end

#puts "OUTPUT IS: #{output}"

Problematic_keyword = Struct.new(:regex, :msg)

RUBY_WARNING_MARKER = ': warning: '
REGEX_PROBLEMATIC = [
  Problematic_keyword.new(%r{#{RUBY_WARNING_MARKER}}, 'Warning generated by Ruby')
]

WARN_METHOD_REDEFINED_DISCARD = 'method redefined; discarding old '
WARN_METHOD_REDEFINED_PREVIOUS = 'previous definition of '

def get_redefinition_regex(redefined_symbol_name)
  %r{#{RUBY_WARNING_MARKER}(#{WARN_METHOD_REDEFINED_DISCARD}\b#{redefined_symbol_name}\b|#{WARN_METHOD_REDEFINED_PREVIOUS}\b#{redefined_symbol_name}\b)}
end

REGEX_OK = [
  get_redefinition_regex('default_bindir'),
  get_redefinition_regex('default_dir'),
  get_redefinition_regex('default_ext_dir_for'),
  get_redefinition_regex('default_path'),
]

def git_ruby_output_whitelist(candidate)
  REGEX_OK.each do |regex|
    return true if regex.match(candidate)
  end
  false
end

# On successful run, check whether content was suspicious:
output.split("\n").each do |line|
  REGEX_PROBLEMATIC.each do |keyword|
    if keyword.regex.match(line)
      # Some parts are legitimate
      # (e.g. warnings due to system-originating code parts)
      if not git_ruby_output_whitelist(line)
        git_hook_fail "Test run of converter #{converter_bin} below #{tests_dir} failed - found forbidden line (#{keyword.msg}):\n#{line}"
      end
    end
  end
end

#git_hook_fail_pseudo

git_hook_ok "Test run of converter successful!"
